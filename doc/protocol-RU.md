# Протокол клиент-серверного взаимодействия

## Номер версии

Номер версии протокола, описанного в данном документе — 1.

## Общее для всех методов

Если метод добавляет/изменяет/удаляет данные на сервере только POST
(singup/score)
Если метод требователен к безопасности только POST (signin/signout)
Если метод только читает данные тогда GET
Поле "status" пересекается с (http статусами)[https://ru.wikipedia.org/wiki/Список_кодов_состояния_HTTP]

* 200 — OK
* 400 — Bad Request — Ошибка запроса
* 401 — Unauthorized — Необходима авторизация
* 404 — Not Found — Данные не найдены
* 405 — Method Not Allowed — Пришли с GET на метод требующий POST
* 500 — Internal Server Error — Ошибка сервера
* 501 — Not Implemented — Метод не реализован
и т.д.

В случае не правильного заполнения необходимых полей, метод возвращает статус 400 и в body содержится информация об ошибках в формате:
```javascript
{
  status: 400,
  body: {
    "name": {
      /* Тип ошибки */
      "error": "required",
      /* Значение, которое валидировал сервер */
      "value": ""
    },
    "password": {
      /* Тип ошибки */
      "error": "badvalue",
      /* Значение, которое валидировал сервер */
      /* Если кто-то отдаст пароль, будет писать юнит тесты на модели для проверки отсутствия пароля в ответах сервера ;-) */
      "value": ""
    }
  }
}
```

## Регистрация

    /api/v<НОМЕР_ВЕРСИИ>/auth/signup/

Принимает только POST запросы

### Пример POST-запроса

Все параметры обязательны. В случае отсутствия одного из параметров будет ошибка 400.

```javascript
{
    name: "Vasya",
    email: "vasya@mail.com",
    password: "topsecret"
}
```

#### Есть пользователь с таким именем/email

Код ответа: 400

```javascript
{
    status: 400,
    body: {
        name: {
          error: "already_exists",
          value: "Vasya"
        }
    }
}
```

#### Успешная регистрация

Код ответа: 200

```javascript
{
    status: 200,
    body: {
        id: 2,
        name: "Vasya",
        email: "vasya@mail.ru",
        score: 0
    }
}
```

## Авторизация

    /api/v<НОМЕР_ВЕРСИИ>/auth/signin/

### Пример POST-запроса

```javascript
{
    email: String,
    password: String
}
```

#### Успешная авторизация

Код ответа: 200

```javascript
{
    status: 200,
    body: {
        id: 2,
        name: "Vasya",
        email: "vasya@mail.ru",
        score: 100500
    }
}
```

## Проверка авторизации и игрового состояния

    /api/v<НОМЕР_ВЕРСИИ>/auth/check/

### Пример GET-запроса

    Без параметров

Ответ сервера будет зависеть от того, в каком игровом состоянии находится пользователь:

#### Авторизован

Код ответа: 200

```javascript
{
    status: 200,
    body: {
        id: 2,
        name: "Vasya",
        email: "vasya@mail.ru",
        score: 100500
    }
}
```

#### Пользователь не залогинен

Код ответа: 401

```javascript
{
    status: 401,
    body: {}
}
```

## Сброс авторизации

    /api/v<НОМЕР_ВЕРСИИ>/auth/signout/

### Пример POST-запроса

    Без параметров.

Ответ сервера будет зависеть от авторизованности пользователя:

#### Пользователь залогинен

Код ответа: 200

```javascript
{
    status: 200,
    body: {}
}
```

#### Пользователь не залогинен

Код ответа: 401

```javascript
{
    status: 401,
    body: {}
}
```

## Игровая статистика

    /api/v<НОМЕР_ВЕРСИИ>/scores/

### Пример GET-запроса

```javascript
{
    sort: {
      by: "date",
      order: "asc"
    }
}
```

Ответ сервера будет зависеть от авторизованности пользователя:

#### Пользователь залогинен

Код ответа: 200
    
    ```javascript
    {
        status: 200,
        body: {}
    }
    ```

#### Пользователь не залогинен

Код ответа: 401

```javascript
{
    status: 401,
    body: {}
}
```

## Игра

Во время игры пользователь подключается по протоколу WebSocket по нижеследующему адресу.

    /api/v<НОМЕР_ВЕРСИИ>/game/

Ответ сервера будет зависеть от текущего состояния клиентской сессии.

### Пользователь не залогинен

Код ответа: 401

```javascript
{
    status: 401,
    body: {}
}
```

### Пользователь залогинен

Устанавливается WebSocket-соединение. Напомним, что WebSocket'ы допускают полнодуплексную отправку сообщений как клиентом, так и сервером.

#### Сообщения от сервера

1. Вы — Наблюдатель

    В случае, если пользователь не может присоединиться к какой-либо команде, он может наблюдать за ходом чьей-либо чужой игры. В этом случае будем называть его *Наблюдателем* (viewer). Сервер может превратить наблюдателя в игрока в любой момент, когда наберётся четыре наблюдателя.

    ```javascript
    {
      type: "viewer_status",
      body: {
        artist: {},
        cassandra: {},
        judges: [
          {}, {}
        ],
        secret: "Cow",
        viewers: [
          {}, {}
        ]
      }
    }
    ```

1. Вы — игрок

    В случае, если пользователя «только и дожидалось» трое человек, формируется новая команда, участником которой он немедленно становится (команды формируются из четвёрок пользователей).

    ```javascript
    {
      type: "player_status",
      body: {
        artist: {}, // Не указывается, если role === "artist"
        cassandra: {}, // Не указывается, если role === "cassandra"
        judges: [
          {}, {} // Указывается только один судья, если role === "judge"
        ],
        role: "cassandra", // или "judge", или "artist"
        secret: "Cow" // Не указывается, если role === "cassandra"
      }
    }
    ```

1. Пользователь отключился

    В случае, если один из игроков команды, за которой наблюдает или в которой участвует клиент, покинул игру или один из наблюдателей покинул игру, сервер посылает клиенту это сообщение. В случае, если игру покинул игрок, продолжаться она больше не может и сервер разрывает WebSocket.

    ```javascript
    {
      type: "user_gone",
      body: {
        id: 13
      }
    }
    ```

1. Пользователь подключился

    В случае, если на сайт зашёл ещё один Наблюдатель, но пока общее количество Наблюдателей меньше четырёх, сервер посылает клиенту это сообщение.

    ```javascript
    {
      type: "user_come",
      body: {
        id: 13,
        name: "Steve",
        score: 100500
      }
    }
    ```

1. Игрок печатает сообщение в чате

    ```javascript
    {
      type: "chat_typing",
      body: {
        id: 13 // id пользователя, который печатает
      }
    }
    ```

1. Игрок закончил печатать сообщение в чате

    ```javascript
    {
      type: "chat_stopped_typing",
      body: {
        id: 13 // id пользователя, который закончил печатать
      }
    }
    ```

1. Новое сообщение в чате

    ```javascript
    {
      type: "chat_message",
      body: {
        id: 13, // id автора сообщения
        text: "Hello, everybody!"
      }
    }
    ```

1. Художник печатает подсказку (prompt)

    ```javascript
    {
      type: "prompt_typing",
      body: {}
    }
    ```

1. Художник закончил печатать подсказку

    ```javascript
    {
      type: "prompt_stopped_typing",
      body: {}
    }
    ```

1. Новое состояние подсказки Художника

    Эти сообщения получают Кассандра, Судьи и Наблюдатели — все, кроме Художника, по мере того, как Художник вводит подсказку Кассандре.

    ```javascript
    {
      type: "prompt_status",
      body: {
        text: "a milky animal with horns"
      }
    }
    ```

1. Кассандра приняла решение

    Это сообщение получают Судьи, Наблюдатели и Художник — все, кроме Кассандры, после того, как Кассандра сделала догадку, либо обвинила Художника в читерстве. После него Художник может прекратить делать подсказки, а Судьи обязаны (если они этого ещё не сделали), решить, является ли Художник читером — каждый независимо.

    ```javascript
    {
      type: "cassandra_decided",
      body: {} // До конца раунда никто не знает, что же решила Кассандра.
    }
    ```

1. Раунд окончен

    Это сообщение получают все пользователи, участвующие или наблюдающие за игрой. Из него можно узнать количество очков, полученное каждым игроком в ходе игры. После него сервер закрывает WebSocket-соединение.

    ```javascript
    {
      type: "round_finished",
      body: {
        artist: {},
        cassandra: {},
        guess: "sheep",
        judges: [
          {}, {}
        ],
        prompt: "a milky animal with horns",
        secret: "Cow"
      }
    }
    ```

#### Сообщения от клиента

1. Игрок печатает сообщение в чате

    ```javascript
    {
      type: "chat_typing",
      body: {}
    }
    ```

1. Игрок закончил печатать сообщение в чате

    ```javascript
    {
      type: "chat_stopped_typing",
      body: {}
    }
    ```

1. Новое сообщение в чат

    Писать в чат могут только игроки. Соединение с наблюдателем, отправившим сообщение, будет разорвано.

    ```javascript
    {
      type: "chat_message",
      body: {
        text: "Hello, everybody!"
      }
    }
    ```

1. Художник печатает подсказку (prompt)

    ```javascript
    {
      type: "prompt_typing",
      body: {}
    }
    ```

1. Художник закончил печатать подсказку

    ```javascript
    {
      type: "prompt_stopped_typing",
      body: {}
    }
    ```

1. Новое состояние подсказки Художника

    Делать подсказки может только Художник. Подсказки других пользователей будут проигнорированы сервером, а соединение с ними разорвано.

    ```javascript
    {
      type: "prompt_status",
      body: {
        text: "a milky animal with horns"
      }
    }
    ```

1. Кассандра приняла решение

    Кассандра должна сделать догадку или заявить, что Художник — читер.

    ```javascript
    {
      type: "cassandra_decided",
      body: {
        guess: "sheep" // или null, если Кассандра считает Художника читером и отказывается делать догадки.
      }
    }
    ```

1. Судья принял решение

    Каждый судья в течение игры обязательно должен принять решение, является ли художник читером. Он принимает решение независимо от Кассандры и другого судьи. После того, как решение получено сервером, судья не может изменить своего мнения. В случае, если судья повторно принимает решение, соединение с ним будет разорвано сервером.

    ```javascript
    {
      type: "judge_decided",
      body: {
        cheater: true
      }
    }
    ```
